# verbose: print some extra information while running.
verbose: True

# If true, figures will be generated and saved to PNG files
figures: True

# Filename prefix for saved data.
# User: Make sure any path used exists.
sim_name: Data\gridresults

# Grid parameters. n = number of
# points in each direction, should be power of 2.
# 2L = box size, i.e., domain is [-L,L].
grid:
  n: 1024
  L: 400
  n_gs: 1024
  L_gs: 50
  gs_tol: 1.0e-7

# Set up kinetic energy.
# The kinetic energy operator is -0.5/mu*d^2/dx^2
kinetic:
  mu: 1836.0

# Set up model potential.
potential:
  U: 'lambda x: -1.0*np.exp(-0.1*x**2)'
  #U: 'lambda x: -1.0/(x**2+2)**.5'
  p: [0.17449, 1.4556, 1.4011]
  #U: 'lambda x: (p[0]*(1.0-np.exp(-p[1]*(x-p[2])))**2*np.heaviside(x, 0.5)+p[0]*(1.0-np.exp(-p[1]*(-x-p[2])))**2*np.heaviside(-x, 0.5))'
  #U: 'lambda x: np.heaviside(x, 0.5)*(p[0]*(1.0-np.exp(-p[1]*(x*(x>0)-p[2])))**2+np.heaviside(-x, 0.5))*p[0]*(1.0-np.exp(-p[1]*(-x-p[2])))**2'
  #ground_state_guess: 'lambda x: np.exp(-(x-p[2])**2/2)+np.exp(-(x+p[2])**2/2)'
  ground_state_guess: 'lambda x: np.random.rand(len(x))'



# Set up laser parameters.
# The pulse function is:
# Efun = lambda t: E0*np.exp(-(t-T)**2/tau**2) * np.cos(om*t)
# Efun = lambda t: (E0*np.sin(om*np.pi*(t-t0)/nc/2)**2
#                   *np.sin(om*(t-t0))
#                   *np.heaviside(t-t0, 1.0)
#                   *np.heaviside(2*nc/om-t+t0))

pulse:
  E0: 0.01
  t0: 20
  om: 0.2672
  nc: 100

# Set up integration parameters.
# t_final: end of simulation time interval
# dt: time step
# n_inspect: number of inspections of densities over
# the simulation interval
# n_save: number of full wavefunction saves.
integration:
  t_final: 800
  dt: 0.08
  n_inspect: 20
